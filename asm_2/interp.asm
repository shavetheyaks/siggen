.include "./m328Pdef.inc"


; ------------------------------------------------------------------------------
; Registers

; r0  ----- Temp (r0:r1 are MUL output, so can't use long-term)
; r1  ----- Temp
; r2  l\___ Interpreter program counter
; r3  h/
; r4  l\___ Current interpreted instruction
; r5  h/
; r6  l\
; r7   |___ Operand A / instruction result
; r8   |
; r9  h/
; r10 l\
; r11  |___ Operand B / instruction result part 2 (mul/div)
; r12  |
; r13 h/
; r14 ----- New flags register value (VF)
; r15 ----- Saved instruction F field
; r16 l\___ Pointer to V[X]
; r17 h/
; r18
; r19
; r20
; r21
; r22
; r23
; r24 ----- Temp
; r25 ----- Temp
; r26 l\_X  HARE reserved
; r27 h/
; r28 l\_Y
; r29 h/
; r30 l\_Z
; r31 h/



; ------------------------------------------------------------------------------
; Interrupt vector table

.cseg

; FIXME: move everything to the bootloader section, let bytecode take low mem
.org 0x0000
	rjmp	reset     ; RESET
	reti
	reti              ; INT0
	reti
	reti              ; INT1
	reti
	reti              ; PCINT0
	reti
	reti              ; PCINT1
	reti
	reti              ; PCINT2
	reti
	reti              ; WDT
	reti
	reti              ; TIMER2 COMPA
	reti
	reti              ; TIMER2 COMPB
	reti
	reti              ; TIMER2 OVF
	reti
	reti              ; TIMER1 CAPT
	reti
	reti              ; TIMER1 COMPA
	reti
	reti              ; TIMER1 COMPB
	reti
	reti              ; TIMER1 OVF
	reti
	reti              ; TIMER0 COMPA
	reti
	reti              ; TIMER0 COMPB
	reti
	reti              ; TIMER0 OVF
	reti
	reti              ; SPI, STC
	reti
	reti              ; USART, RX
	reti
	reti              ; USART, UDRE
	reti
	reti              ; USART, TX
	reti
	reti              ; ADC
	reti
	reti              ; EE READY
	reti
	reti              ; ANALOG COMP
	reti
	reti              ; TWI
	reti
	reti              ; SPM READY
	reti


; ------------------------------------------------------------------------------
; Reset entry point

reset:
	; ----- Disable interrupts and set stack pointer to top of SRAM

	clr	r25
	out	SREG, r25
	ldi	r25, HIGH(RAMEND)
	out	SPH, r25
	ldi	r25, LOW(RAMEND)
	out	SPL, r25

	; ----- Reset interpreter state

	; TODO

	; --------------------------------------------------------------
	; Main loop
loop:
	; Check for pin change interrupt flag and debounce switches
	; TODO

	; Fetch instruction
	movw	ZL, r2     ; Put bytecode PC into Z
	lsl	ZL         ; *2 to get a byte address from a word address
	rol	ZH
	lpm	r4, Z+     ; Load a word and increment
	lpm	r5, Z+
	lsr	ZH         ; /2 to get a word address from a byte address
	ror	ZL
	movw	r2, ZL     ; Save updated bytecode PC

	; Decode first operand, always register V[X]
	mov	r24, r5    ; Extract X field from instruction
	andi	r24, 0x0f
	lsl	r24        ; *4 to get an offset from an index
	lsl	r24
	clr	r25        ; Add offset to base address of registers
	ldi	ZL, LOW(interp_regs)
	ldi	ZH, HIGH(interp_regs)
	add	ZL, r24
	adc	ZH, r25
	movw	r16, ZL    ; Save the reg addr for use as destination later
	ldd	r6, Z+0    ; Load operand value
	ldd	r7, Z+1
	ldd	r8, Z+2
	ldd	r9, Z+3

	; Decode second operand based on instruction F field
	mov	r24, r5    ; Extract F field from instruction
	lsr	r24
	lsr	r24
	lsr	r24
	lsr	r24
	clr	r25        ; Add base address of operand-dispatch jumptable
	ldi	ZL, LOW(operand_jumptable)
	ldi	ZH, HIGH(operand_jumptable)
	add	ZL, r24
	adc	ZH, r25
	mov	r15, r24   ; Save the F field for decoding instruction later
	ijmp	           ; Jump to whatever code decodes the other operand
_decode_done:

	; Dispatch based on instruction F field
	mov	r24, r15   ; Recover saved F field from instruction
	clr	r25        ; Add base address of instruction-dispatch jumptable
	ldi	ZL, LOW(f_dispatch_jumptable)
	ldi	ZH, HIGH(f_dispatch_jumptable)
	add	ZL, r24
	adc	ZH, r25
	ijmp               ; Jump to whatever code runs this type of instruction
_dispatch_done_writeback_flags:
	ldi	r24, 0xc3  ; Index of the VF register (0xf * 4)
	clr	r25        ; Add offset to base address of registers
	ldi	ZL, LOW(interp_regs)
	ldi	ZH, HIGH(interp_regs)
	add	ZL, r24
	adc	ZH, r25
	st	Z, r14     ; Store the flag byte generated by the instruction
_dispatch_done_writeback_reg:
	movw	ZL, r16    ; Recover the pointer to V[X]
	std	Z+0, r6    ; Save the instruction result to the register
	std	Z+1, r7
	std	Z+2, r8
	std	Z+3, r9
_dispatch_done:

	rjmp	loop


; ------------------------------------------------------------------------------
; Operand decoding

operand_jumptable:
	.dw	operand_VY
	.dw	operand_imm32
	.dw	operand_Y
	.dw	operand_VY_N
	.dw	operand_VY_N
	.dw	operand_VY_N
	.dw	operand_VY_N
	.dw	operand_VY_N
	.dw	operand_VY_N
	.dw	operand_none
	.dw	operand_0NNN
	.dw	operand_PC_ssNN
	.dw	operand_PC_sNNN
	.dw	operand_PC_sNNN
	.dw	operand_none
	.dw	operand_none


; ----- V[Y]
operand_VY:
	mov	r24, r4
	andi	r24, 0xf0
	lsr	r24
	lsr	r24
	clr	r25
	ldi	ZL, LOW(interp_regs)
	ldi	ZH, HIGH(interp_regs)
	add	ZL, r24
	adc	ZH, r25
	ldd	r10, Z+0
	ldd	r11, Z+1
	ldd	r12, Z+2
	ldd	r13, Z+3

	rjmp	_decode_done


; ----- 32-bit immediate following instruction
operand_imm32:
	movw	ZL, r2     ; Put bytecode PC into Z
	lsl	ZL         ; *2 to get a byte address from a word address
	rol	ZH
	lpm	r10, Z+    ; Load four bytes and increment
	lpm	r11, Z+
	lpm	r14, Z+
	lpm	r13, Z+
	lsr	ZH         ; /2 to get a word address from a byte address
	ror	ZL
	movw	r2, ZL     ; Save updated bytecode PC

	rjmp	_decode_done


; ----- 4-bit zero-extended immediate within instruction
operand_Y:
	mov	r10, r4
	lsr	r10
	lsr	r10
	lsr	r10
	lsr	r10
	clr	r11
	clr	r12
	clr	r13

	rjmp	_decode_done


; ----- V[Y] + 4-bit zero-extended immediate within instruction
operand_VY_N:
	; Load V[Y]
	mov	r24, r4
	andi	r24, 0xf0
	lsr	r24
	lsr	r24
	clr	r25
	ldi	ZL, LOW(interp_regs)
	ldi	ZH, HIGH(interp_regs)
	add	ZL, r24
	adc	ZH, r25
	ldd	r10, Z+0
	ldd	r11, Z+1
	ldd	r12, Z+2
	ldd	r13, Z+3

	; Add N
	mov	r24, r4
	andi	r24, 0x0f
	clr	r25
	add	r10, r24
	adc	r11, r25
	adc	r12, r25
	adc	r13, r25

	rjmp	_decode_done


; ----- Zero-extended 12-bit immediate within instruction
operand_0NNN:
	movw	r10, r4
	ldi	r25, 0x0f
	and	r11, r25
	clr	r12
	clr	r13
	rjmp	_decode_done


; ----- PC + sign-extended 8-bit immediate within instruction
operand_PC_ssNN:
	; Sign-extend 8-bit immediate
	mov	r10, r4
	clr	r11
	clr	r12
	clr	r13
	sbrs	r10, 7
	rjmp	_sext_done_PCssNN
	com	r11
	com	r12
	com	r13
_sext_done_PCssNN:

	; Add PC
	clr	r25
	add	r10, r2
	adc	r11, r3
	adc	r12, r25
	adc	r13, r25

	rjmp	_decode_done


; ----- PC + sign-extended 12-bit immediate within instruction
operand_PC_sNNN:
	; Sign-extend 12-bit immediate
	movw	r10, r4
	ldi	r25, 0x0f
	and	r11, r25
	clr	r12
	clr	r13
	sbrs	r11, 3
	rjmp	_sext_done_PCsNNN
	ldi	r25, 0xf0
	or	r11, r25
	com	r12
	com	r13
_sext_done_PCsNNN:

	; Add PC
	clr	r25
	add	r10, r2
	adc	r11, r3
	adc	r12, r25
	adc	r13, r25

	rjmp	_decode_done


operand_none:
	rjmp	_decode_done


; ------------------------------------------------------------------------------
; Instruction dispatch

f_dispatch_jumptable:
	.dw	dispatch_alu
	.dw	dispatch_alu
	.dw	dispatch_imm4
	.dw	exec_ldb
	.dw	exec_ldh
	.dw	exec_ldw
	.dw	exec_stb
	.dw	exec_sth
	.dw	exec_stw
	.dw	exec_nop
	.dw	exec_avr
	.dw	dispatch_branch
	.dw	exec_jal_with_ve
	.dw	exec_jmp
	.dw	exec_nop
	.dw	exec_nop

alu_dispatch_jumptable:
	.dw	exec_add
	.dw	exec_sub
	.dw	exec_and
	.dw	exec_or
	.dw	exec_xor
	.dw	exec_nor
	.dw	exec_mov
	.dw	exec_mul
	.dw	exec_div
	.dw	exec_cmp
	.dw	exec_test
	.dw	exec_nop
	.dw	exec_nop
	.dw	exec_nop
	.dw	exec_nop
	.dw	exec_jal

imm4_dispatch_jumptable:
	.dw	exec_add
	.dw	exec_sub
	.dw	exec_shl
	.dw	exec_shrl
	.dw	exec_shra
	.dw	exec_rol
	.dw	exec_ror
	.dw	exec_nop
	.dw	exec_nop
	.dw	exec_spi
	.dw	exec_mft
	.dw	exec_mtt
	.dw	exec_din
	.dw	exec_dout
	.dw	exec_ain
	.dw	exec_aout

branch_dispatch_jumptable:
	.dw	exec_bz
	.dw	exec_bnz
	.dw	exec_bgt
	.dw	exec_blt
	.dw	exec_blte
	.dw	exec_bgte
	.dw	exec_bc
	.dw	exec_bnc
	.dw	exec_nop
	.dw	exec_nop
	.dw	exec_nop
	.dw	exec_nop
	.dw	exec_nop
	.dw	exec_nop
	.dw	exec_nop
	.dw	exec_nop


dispatch_alu:
	mov	r24, r4
	andi	r24, 0x0f
	clr	r25
	ldi	ZL, LOW(alu_dispatch_jumptable)
	ldi	ZH, HIGH(alu_dispatch_jumptable)
	add	ZL, r24
	adc	ZH, r25
	ijmp

dispatch_imm4:
	mov	r24, r4
	andi	r24, 0x0f
	clr	r25
	ldi	ZL, LOW(imm4_dispatch_jumptable)
	ldi	ZH, HIGH(imm4_dispatch_jumptable)
	add	ZL, r24
	adc	ZH, r25
	ijmp

dispatch_branch:
	mov	r24, r5
	andi	r24, 0x0f
	clr	r25
	ldi	ZL, LOW(branch_dispatch_jumptable)
	ldi	ZH, HIGH(branch_dispatch_jumptable)
	add	ZL, r24
	adc	ZH, r25
	ijmp


exec_nop:
exec_add:
exec_sub:
exec_and:
exec_or:
exec_xor:
exec_nor:
exec_mov:
exec_mul:
exec_div:
exec_cmp:
exec_test:
exec_jal:
exec_shl:
exec_shrl:
exec_shra:
exec_rol:
exec_ror:
exec_spi:
exec_mft:
exec_mtt:
exec_din:
exec_dout:
exec_ain:
exec_aout:
exec_ldb:
exec_ldh:
exec_ldw:
exec_stb:
exec_sth:
exec_stw:
exec_avr:
exec_bz:
exec_bnz:
exec_bgt:
exec_blt:
exec_blte:
exec_bgte:
exec_bc:
exec_bnc:
exec_jal_with_ve:
exec_jmp:
	rjmp	_dispatch_done


; ------------------------------------------------------------------------------
; Interpreter state

.dseg

; 16 general purpose 32-bit "registers" (V0-VF)
interp_regs:
	.byte	16*4

